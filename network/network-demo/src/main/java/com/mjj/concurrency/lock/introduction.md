```text



    显示锁Lock
    
    Lock接口和核心方法
    
    Lock接口和synchronized比较
    
    synchronized代码简洁  【jdk1.6后性能显著提升】，锁的膨胀 轻量级锁-乐观锁-自旋
    
    什么情况下需要使用显示锁
        1. 获取锁的时候可以被中断
        2. 可以尝试性的获取锁
        3. 可以超时的获取锁
        
    如果不需要，尽量使用synchronized关键字，性能优化
        
        
        
        
    可重入锁
    公平锁、非公平锁 
        
        如果在时间上，先对锁进行获取的请求，一定先被满足，则为公平锁，反之为非公平锁
        非公平锁的效率一般来讲更高
        
        
        为什公平锁的效率低
        
        若使用非公平锁加锁，那么线程进入后，会立即尝试一次加锁，加锁失败后。非公平锁和公平锁
        的处理逻辑相同
        
        公平锁效率慢的原因
        1. 当锁资源空闲时，即使有线程进入，公平锁大多数情况下借助操作操作系统恢复唤醒第一个
           排队的节点线程
        2. 寻找第一个排队的节点线程，会采取tail节点向前遍历，可能会存在性能上的问题
        
        
    读写锁
    ReadWriteLock接口
    读锁 ReadLock
    写锁 WriteLock
    ReentrantLock synchronized 排他锁， 
    读写锁，同一时刻允许多读线程同时访问，但是写线程，所有的读和写都被阻塞
``` 